---
title: "Scent Data Analysis"
author: "Jack Rechsteiner"
date: "2025-06-19"
output: 
  github_document: 
    toc: TRUE
---

```{r setup}
##Set knitr options (show both code and output, show output w/o leading #)
knitr::opts_chunk$set(echo = TRUE, include = TRUE, comment=NA, fig.path = "Images/")

#load tidyverse
library("tidyverse")
#loading country package for easy filtering
library(r2country)
```

# Looking for outliers and such
```{r}
#reading in RDS
fragrance_df <- 
  readRDS('/Users/jack/Workshop/Scent Project/RDS_files/cleaned_fragrance_df.RDS') %>% 
  #removing the rowwise grouping
  ungroup() %>% 
  #dropping duplicated rows
  distinct()

cleaned_fragrance_df <-
  fragrance_df %>% 
  #removing fragrances with a year before 1980 (1.2% of total dataset)
  filter(year > 1980) %>% 
  #keeping the url as unique id but moving it to the end so I don't have to keep looking at it
  relocate(fragrance_url, .after = last_col()) 

dupes_removed <-
  cleaned_fragrance_df %>%
  #finding all the EAU DE whatevers
  filter(str_detect(fragrance_name, "EAU DE (EXTRAIT|PARFUM|TOILETTE)")) %>% 
  #sorting alphabetically for my own sanity
  arrange(fragrance_name) %>% 
  #separating the columns into name and fragrance type
  separate_wider_regex(fragrance_name, c(fragname =".+", fragtype = "EAU .+"), cols_remove = FALSE) %>% 
  #grouping by fragrance name
  group_by(fragname) %>% 
  #keeping only a singular fragrance
  distinct(fragname, .keep_all = TRUE) %>% 
  #removing grouping
  ungroup() %>% 
  #dropping the separated columns to bind dfs back together
  select(!fragname:fragtype)

#this feels like a really dumb way to do this but I'm feeling dumb today
#making a df with the opposite filter
recleaned_fragrance_df <-
  cleaned_fragrance_df %>%
  #finding everything but the EAU DE fragrances
  filter(!str_detect(fragrance_name, "EAU DE (EXTRAIT|PARFUM|TOILETTE)")) %>% 
  #adding the other df back in
  rbind(dupes_removed) %>% 
  #also going to drop LA PETITE ROBE NOIRE EDT SO FRENCHY 2020 while I'm at it because it's a dupe of LA PETITE ROBE NOIRE EDP SO FRENCHY 2020
  filter(!str_detect(fragrance_name, "LA PETITE ROBE NOIRE EDT SO FRENCHY 2020"))
```

## Total concept counts

```{r}
#storing concept words as lists to make the later code cleaner
named_locations <- "Comores|Sweede|African|British|Cambodge|Phillipines|Asian|(Central|South|North) America(n)?|European|Somalie|Australie|England|West Indies|Calabria|Mediterranean|Sicily"

source_based <- "Iodine|Mildew|Roots|Latex|Plastic|Sweaty|Algae|Nutty|Pencil|Milky|Sea|Fur|Organza|Almond|Ink|Animal|Soapy|Medicinal|Powdery|Cotton|Detergent|Salt|Laundry|Air-Freshner|Silk|Caramelized|Creamy|Garden|Grassy|Metal(l)?ic|Ocean|Honeyed|Smoky|Sugary|Candy|Salty|Spicy|Leather|Fruity|Orange|Herbal|Musky|Leaf|Rain|Shrub|Earth|Mossy|Zesty|Forest|Citrus|Ambery|Ozone|Camphoric|Lavender|Earthy|Floral|Woody|Gloves"

abstract_cross_modal <- "Culture|Fantasy|Nature|Cold|Soft|Tropical|Humid|Dry|Beach|Culinary|Mountain|Bitter|Breeze|Outdoor|Countryside|Yummy|Fields|Funfair|Chrismacy|Glitters|Desert|Mouth-Watering|Appetizing|Delicious|Bright|Darkness|Chrismas|Tender|Textured|Airy|Supple|Heady|Velvety|Luminous|Aquatic|Natural|Pure|Smooth|Holidays|Dark|Heat|Sweet|Hot|Marine|Light|Sunny|Deep|Warm|Colourful|Fresh|Radiant|Loud|Clean|Sparkling|Summer|Blooming|Spring|Night|Round|Winter|Autum|Day|City|Childhood|Cristals"

evaluative_persona <- "Artistic|Classic|Banal|Professional|Quircky|Witty|Aristocratic|Eccentric|Formal|Childish|Old-Fashioned|Oldie|Opulent|Avant Garde|Sickening|Iconic|Graceful|Flamboyant|Luscious|Masculine|Noble|Clean Cut|Modern|Minimalistic|Daring|Bold|Luxury|Suave|Fashion|Authentic|Innocent|Classy|Primitive|Mystical|Original|Oriental|Girly|Sophisticated|Unisexe|Affirmed|Self-Confident|Carnal|Feminine|Dynamic|Sporty|Exotic|Elegant|Romantic|Generous|Casual|Everyday|Heritage|Greedy|Craftmanship"

effect_emotion <- "Serene|Tranquility|Relaxing|Reassuring|Melancholy|Nostalgia|(E|I)nvigorating|Stimulating|Exciting|Energetic|Comfortable|Joyful|Energyzing|Happy|Cheerful|Freedom|Optimistic"

intensity <- "Imperceptible|Feathers|Aggressive|Discrete|Pervasive|Transparent|Wrapping|Enveloping|Watery|Strong|Vaporous|Noticeable|Heavy|Powerful|Robust|Intense|Rich"

composition_fragrance_jargon <- "Aldehydic|Astringent|Resinous|Mineral|Chemical|Fixative|Acid|Pungent|Gourmand|Vertical|Aromatic"

#look into "colors" as a whole category but also look at how the colors individually pattern in relation to price

colors <- "Blue|Silver|Red|Yellow|Pink|Green|Gold|Grey|Purple|Black|Brown|White"

#be wary, the resulting df is big
split_concepts_df <-
  recleaned_fragrance_df %>% 
  #dropping some columns to make the df a little less gigantic
  select(fragrance_name:brand_name, price, origin:concepts) |> 
  #turning the comma strings of concepts into a one concept per row
  separate_longer_delim(cols = "concepts", delim = ", ") %>% 
  #somehow that introduced a singular blank row, so I'll filter that out
  ##also "rehash" only occurs once and its like a meta-descriptor, so we'll drop that too
  filter(concepts != c("", "Rehash")) %>% 
  #converting all strings to sentence case
  mutate(across(concepts, ~ str_to_title(.x))) %>% 
  #using case_when and str_detect to sort the concepts into different categories...
  ##using the saved strings from above
  mutate(concept_bin = case_when(
    #using str_flatten and the country_names data from r2country to save some time
    str_detect(concepts, str_flatten(country_names$name, collapse = "|")) ~ "named location",
    str_detect(concepts, named_locations) ~ "named location",
    str_detect(concepts, source_based) ~ "source-based",
    str_detect(concepts, abstract_cross_modal) ~ "abstract/cross-modal",
    str_detect(concepts, evaluative_persona) ~ "evaluative/persona",
    str_detect(concepts, effect_emotion) ~ "effect/emotion",
    str_detect(concepts, intensity) ~ "intensity",
    str_detect(concepts, composition_fragrance_jargon) ~ "composition/fragrance jargon",
    str_detect(concepts, colors) ~ "color",
    .default = "unassigned"))
```

### Analyses using total concept counts

```{r}
#seeing if infrequent concept words occur more often with expensive perfumes
split_concepts_df |> 
  #get counts for concepts
  add_count(concepts, name = "concept_count") |> 
  #getting total of each price point before mutating df further
  add_count(price, name = "price_total_tokens") |> 
  #filtering to only concepts that appear 10 or less times
  filter(concept_count <= 10) |> 
  #getting count for number of times that each price occurs
  add_count(price, name = "price_count") |> 
  #dividing the infrequent concept count each price's total tokens to account for size differences
  mutate(percent_of_total = (price_count/price_total_tokens)*100) |> 
  #this is probably such a bad way to do this but I wanna wrap this up and go to bed
  group_by(price) |> 
  slice(1) |> 
  select(price, price_total_tokens:percent_of_total)
  
```


```{r conceptbinsbyprice}
#comparing concept bins across prices
split_concepts_df |> 
  #group by price
  group_by(price) |> 
  #get counts for concept bins
  count(concept_bin) |> 
  #calculate counts as within-group percentages
  mutate(percent  = (n / sum(n) * 100),
         #get within-group totals while I'm at it
         total = sum(n)) |> 
  #split df by price for easier comparison
  (\(.)split(., f = .$price))()
```


```{r}
#this section is represented with a graph later on but i'm leaving this code here for posterity
# #comparing individual concepts by price and gender
# split_concepts_df |> 
#   #creating a column that combines gender and price to use for grouping
#   mutate(gender_price = str_c(gender, " - ", price)) %>% 
#   #grouping by gender_price to analyze concept frequencies within gender_price
#   group_by(gender_price) %>% 
#   #get counts for concepts
#   count(concepts) |> 
#   #sort in order for slicing later
#   arrange(desc(n)) |> 
#   #calculate counts as within-group percentages
#   mutate(percent  = (n / sum(n) * 100),
#          #get within-group totals while I'm at it
#          total = sum(n)) |> 
#   #split df by price for easier comparison
#   (\(.) split(., f = .$gender_price))() |> 
#   #mapping to get the first 14 concepts for each group
#   map(\(df) slice(df, 8:14))
```


```{r colorsbyprice}
#looking at individual colors across price points
split_concepts_df |> 
  #filtering to only keep color concepts
  filter(concept_bin == "color") |> 
  #group by price
  group_by(price) |> 
  #get counts for concept bins
  count(concepts) |> 
  #calculate counts as within-group percentages
  mutate(percent  = (n / sum(n) * 100),
         #get within-group totals while I'm at it
         total = sum(n)) |> 
  #split df by price for easier comparison
  (\(.)split(., f = .$price))()
```

```{r emotionsbyprice}
#looking at individual colors across price points
split_concepts_df |> 
  #filtering to only keep color concepts
  filter(concept_bin == "effect/emotion") |> 
  #group by price
  group_by(price) |> 
  #get counts for concept bins
  count(concepts) |> 
  #calculate counts as within-group percentages
  mutate(percent  = (n / sum(n) * 100),
         #get within-group totals while I'm at it
         total = sum(n)) |> 
  #split df by price for easier comparison
  (\(.)split(., f = .$price))()
```

## Concepts by price and gender
```{r gendergraphs}
#gender graphs
recleaned_fragrance_df %>% 
  #turning the comma strings of concepts into a one concept per row
  separate_longer_delim(cols = "concepts", delim = ", ") %>% 
  #somehow that introduced a singular blank row, so I'll filter that out
  filter(concepts != "") %>% 
  #selecting the relevant columns
  select(price, gender, concepts) %>% 
  #grouping by gender to analyze concept frequencies within gender
  group_by(gender) %>% 
  #counting concepts
  count(concepts) %>% 
  #arranging the counts from highest to lowest
  arrange(desc(n)) %>% 
  ungroup() %>% 
  #splitting the df into multiple dfs for each gender
  split(., f = .$gender) %>%
  #mapping the multiple dfs to just give the 7 highest count concepts using 1:7
  ##or the next 7 highest using 8:14
  map(., ~ slice(.x, 8:14)) %>% 
  #mapping the dfs to make column charts for the counts of concepts with a static y-axis limit to help comparability
  map(., ~ ggplot(.x, aes(x = concepts, y = n)) + geom_col() + ylim(0, 8000))
```


```{r pricegraphs}
#price graphs
recleaned_fragrance_df %>% 
  #turning the comma strings of concepts into a one concept per row
  separate_longer_delim(cols = "concepts", delim = ", ") %>% 
  #somehow that introduced a singular blank row, so I'll filter that out
  filter(concepts != "") %>% 
  #selecting the relevant columns
  select(price, gender, concepts) %>% 
  #grouping by price to analyze concept frequencies within price
  group_by(price) %>% 
  #counting concepts
  count(concepts) %>% 
  #arranging the counts from highest to lowest
  arrange(desc(n)) %>% 
  ungroup() %>% 
  #splitting the df into multiple dfs for each price
  split(., f = .$price) %>%
  #mapping the multiple dfs to just give the 7 highest count concepts using 1:7
  ##or the next 7 highest using 8:14
  map(., ~ slice(.x, 8:14)) %>% 
  #mapping the dfs to make column charts for the counts of concepts with a static y-axis limit to help comparability
  map(., ~ ggplot(.x, aes(x = concepts, y = n)) + geom_col() + ylim(0, 8000))
```


```{r priceandgendergraphs}
#price and gender graphs
recleaned_fragrance_df %>% 
  #turning the comma strings of concepts into a one concept per row
  separate_longer_delim(cols = "concepts", delim = ", ") %>% 
  #somehow that introduced a singular blank row, so I'll filter that out
  filter(concepts != "") %>% 
  #selecting the relevant columns
  select(price, gender, concepts) %>% 
  #creating a column that combines gender and price to use for grouping
  mutate(gender_price = str_c(gender, " - ", price)) %>% 
  #grouping by gender_price to analyze concept frequencies within gender_price
  group_by(gender_price) %>% 
  #counting concepts
  count(concepts) %>% 
  #arranging the counts from highest to lowest
  arrange(desc(n)) %>% 
  #splitting the df into multiple dfs for each gender_price
  split(., f = .$gender_price) %>% 
  #mapping the multiple dfs to just give the 7 highest count concepts using 1:7
  ##or the next 7 highest using 8:14
  map(., ~ slice(.x, 8:14)) %>% 
  #mapping the dfs to make column charts for the counts of concepts with a static y-axis limit to help comparability
  map(., ~ ggplot(.x, aes(x = concepts, y = n)) + geom_col() + ylim(0, 8000))
```


## Getting concept scores for each fragrance

I want to keep working with this.
I feel like something interesting might be found by investigating fragrances by concept score.

```{r}
frags_with_concept_scores <- 
  recleaned_fragrance_df %>% 
  mutate(concepts_copy = concepts,
         across(concepts_copy, ~ str_to_title(.x)),
         across(concepts_copy, ~ str_replace_all(.x, str_flatten(country_names$name, collapse = "|"), "named location")),
         #str_replace_all wasn't working with the usual c() method to combine replacements together,
         ##so I just went with a less elegant solution
         across(concepts_copy, ~ str_replace_all(.x, named_locations, "named location")),
         across(concepts_copy, ~ str_replace_all(.x, source_based, "source-based")),
         across(concepts_copy, ~ str_replace_all(.x, abstract_cross_modal, "abstract/cross modal")),
         across(concepts_copy, ~ str_replace_all(.x, evaluative_persona, "evaluative/persona")),
         across(concepts_copy, ~ str_replace_all(.x, effect_emotion, "effect/emotion")),
         across(concepts_copy, ~ str_replace_all(.x, intensity, "intensity")),
         across(concepts_copy, ~ str_replace_all(.x, composition_fragrance_jargon, "composition/jargon")),
         across(concepts_copy, ~ str_replace_all(.x, colors, "colors")),
         location_score = str_count(concepts_copy, "named location"),
         sourcebased_score = str_count(concepts_copy, "source-based"),
         abstract_score = str_count(concepts_copy, "abstract/cross modal"),
         evaluative_score = str_count(concepts_copy, "evaluative/persona"),
         effect_score = str_count(concepts_copy, "effect/emotion"),
         intensity_score = str_count(concepts_copy, "intensity"),
         composition_jargon_score = str_count(concepts_copy, "composition"),
         color_score = str_count(concepts_copy, "colors")) %>% 
  select(!concepts_copy)

frags_with_concept_scores
```

# Identifying brands with lots of price variation

```{r}
recleaned_fragrance_df %>% 
  group_by(brand_name) %>% 
  count(price, name = "price_count") %>% 
  add_count(brand_name, name = "brand_count") %>% 
  filter(brand_count == 3)

recleaned_fragrance_df %>% 
  group_by(brand_name) %>% 
  count(price, name = "price_count") %>% 
  add_count(brand_name, name = "brand_count") %>% 
  filter(brand_count == 2)

#creating csv to use the Chopard fragrances as a case study
# recleaned_fragrance_df %>% 
#   filter(brand_name == "Chopard") |> 
#   write_csv("Chopard_fragrances.csv")

#creating csv to use the 4711 fragrances as a case study
# recleaned_fragrance_df %>%
#   filter(brand_name == "4711") |> 
#    write_csv("4711_fragrances.csv")
```

# Getting counts of olfactive family, olfactive subfamily, and fragrance classifier

```{r}
recleaned_fragrance_df %>% 
  count(olfactive_family)

recleaned_fragrance_df %>% 
  count(olfactive_subfamily)

recleaned_fragrance_df %>% 
  count(frag_classifier)
```


# Session Info

```{r}
sessionInfo()
```